#install anndata
!pip install anndata

# importing anndata
import anndata as ad

# importing numpy and pandas as well
import numpy as np
import pandas as pd

# importing scRNA-seq data from a .h5ad file
scdr = ad.read_h5ad('scdr.h5ad')
scdr

#here the cells are in the rows of scdr.X and the columns of scrd.X are genes. Our data is of the shape (5016, 20953)

# first 10 highest expression values.
np.flip(np.sort(scdr.X.data))[range(10)]

# selecting only Naive T-cells
ids = scdr.obs['cell.type'] == 'Naive'
scdr = scdr[ids, :]
scdr
#scdr now contains only the 2141 Naive cells

# summing over the first axis / dimension
num_reads = scdr.X.sum(axis=0)
num_reads
#computing the total number of reads for each gene across all cells

# creating the vars data frame
scdr.var = pd.DataFrame({'num_reads':np.array(num_reads).flatten()}, index=scdr.var_names)
scdr.var

#preprocessing

#installing scanpy
!pip install scanpy
import scanpy as sc

# loading the T-cell data
scdr = sc.read_h5ad('scdr.h5ad')
(scdr.n_obs, scdr.n_vars)

# filtering cells with less than 200 expressed genes
sc.pp.filter_cells(scdr, min_genes=200)
(scdr.n_obs, scdr.n_vars)
#No cells were eliminated this time

# filtering genes with are expressed in only 3 or less cells
sc.pp.filter_genes(scdr, min_cells=3)
(scdr.n_obs, scdr.n_vars)
#14699 genes remain 

# the names of mitochondrial genes starts with 'MT-'.Creating a boolean column in the var data frame to identify them
scdr.var['mt'] = scdr.var_names.str.startswith('MT-')

# The following function will compute the percentage of mithocondrial reads for each cell
sc.pp.calculate_qc_metrics(scdr, qc_vars=['mt'], percent_top=None, log1p=False, inplace=True)

# plotting quality control violin plots
sc.pl.violin(scdr, ['n_genes_by_counts', 'total_counts', 'pct_counts_mt'], jitter=0.4, multi_panel=True)

# filtering out possible doublets
scdr = scdr[scdr.obs.n_genes_by_counts < 2000, :].copy()
(scdr.n_obs, scdr.n_vars)

# filtering out cells possibly affected by contamination
scdr = scdr[scdr.obs.pct_counts_mt < 5, :].copy()
(scdr.n_obs, scdr.n_vars)

# plotting again the quality control violin plots
sc.pl.violin(scdr, ['n_genes_by_counts', 'total_counts', 'pct_counts_mt'], jitter=0.4, multi_panel=True)

# summing reads for each cell
library_size = scdr.X.sum(axis = 1)

# transforming in a pandas data frame
library_size = pd.DataFrame({'library size':np.array(library_size).flatten()}, index=scdr.obs_names)

# plotting the library size distribution
tmp = library_size.hist(bins=20)

# normalization. After normalization each cell will have approximately 1e4 normalized reads
sc.pp.normalize_total(scdr, target_sum=1e4)

# new library size
library_size = scdr.X.sum(axis = 1)
(library_size.min(), library_size.max())

# histogram of all values
tmp = np.array(scdr.X.todense()).flatten()
tmp = tmp[tmp > 0]
tmp = pd.DataFrame({'values': tmp}).hist(bins=100)

# log transforming the values
sc.pp.log1p(scdr)

# histogram of all values
tmp = np.array(scdr.X.todense()).flatten()
tmp = tmp[tmp > 0]
tmp = pd.DataFrame({'values': tmp}).hist(bins=100)

# identifying the genes with the highest variation
sc.pp.highly_variable_genes(scdr)
sc.pl.highly_variable_genes(scdr)

# what is the percentage of highly variable genes?
print('%.1f' % np.round(scdr.var.highly_variable.sum()/scdr.n_vars * 100, 3) + '%')

# current status of the data stored in "raw"
scdr.raw = scdr.copy()

# selecting only the most variable genes
scdr = scdr[:, scdr.var.highly_variable].copy()
scdr.n_vars

# scaling
sc.pp.scale(scdr, max_value=10)

# saving the data
scdr.write_h5ad('scdr_preprocessed.h5ad')

#cell type identification

# PCA. 
sc.tl.pca(scdr, svd_solver='arpack')

# PCA plot.
sc.pl.pca_variance_ratio(scdr, log=True)

# clustering: identification of the closest neighbors.
sc.pp.neighbors(scdr, n_neighbors=10, n_pcs=30)

# clustering: applying the Leiden algorithm
sc.tl.leiden(scdr)

# the clusters are recorded in the 'leiden' column of the obs data fram
scdr.obs['leiden']

# computing the UMAP
sc.tl.umap(scdr)

# visualizing the UMAP
sc.pl.umap(scdr, color = 'leiden')

# find the differentially expressed genes characterizing each cluster
sc.tl.rank_genes_groups(scdr, 'leiden', method='t-test')

# for each cluster, plot the 25 most differentially expressed genes
sc.pl.rank_genes_groups(scdr, n_genes=25, sharey=False)

scdr.obs['cell_identity'] = ''

# assigning cluster 6 cells to the "EMRA T-cell" type
scdr.obs.loc[scdr.obs.leiden == '6', 'cell_identity'] = 'TEMRA'

# storing the identified cell types in the "cell_identity" column
ids = (scdr.obs.leiden == '0') | (scdr.obs.leiden == '3') | (scdr.obs.leiden == '5')
scdr.obs.loc[ids, 'cell_identity'] = 'TN'
ids = (scdr.obs.leiden == '1') | (scdr.obs.leiden == '2')
scdr.obs.loc[ids, 'cell_identity'] = 'TCM'
ids = scdr.obs.leiden == '4'
scdr.obs.loc[ids, 'cell_identity'] = 'TEM'

# plotting the UMAP using colors for marking cell identities
sc.pl.umap(scdr, color = 'cell_identity')






























